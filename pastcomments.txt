use core::panic;
use std::{
    collections::{BTreeMap, HashMap, HashSet},
    ffi::c_void,
    path::Path,
    sync::{
        atomic::{AtomicI32, AtomicI8, AtomicU32, Ordering::Relaxed},
        Mutex,
    },
    time::{Duration, Instant, SystemTime},
    todo,
};
mod netcode;
mod rollback;

use dashmap::{DashMap, DashSet};
use ilhook::x86::{HookFlags, HookPoint, HookType};
use libloading::Library;
use log::info;
use notify::{RecursiveMode, Watcher};
use rollback::Rollbacker;
use windows::{
    imp::{HeapFree, WaitForSingleObject},
    Win32::{
        Networking::WinSock::{sendto, WSAGetLastError, SOCKADDR, SOCKET},
        System::Memory::{HeapAlloc, HeapHandle, VirtualProtect, PAGE_PROTECTION_FLAGS},
    },
};

//mod netcode;
//+83E1
// +2836D
//004083dc actually
//00407a21 game thread created here!

//#[cfg(debug_assertions)]
const ISDEBUG: bool = false;
//#[cfg(not(debug_assertions))]
//const ISDEBUG: bool = false;

pub fn set_up_fern() -> Result<(), fern::InitError> {
    fern::Dispatch::new()
        // Perform allocation-free log formatting
        .format(|out, message, record| {
            out.finish(format_args!(
                "[{} {} {}] {}",
                humantime::format_rfc3339(std::time::SystemTime::now()),
                record.level(),
                record.target(),
                message
            ))
        })
        // Add blanket level filter -
        .level(log::LevelFilter::Debug)
        .chain(fern::log_file("output.log")?)
        // Apply globally
        .apply()?;

    Ok(())
}

/*#[no_mangle]
pub extern "cdecl"*/
fn init(_: usize) -> Option<()> {
    const BPATH: &'static str = r"C:\Users\Giuuu\Desktop\giuroll\giuroll\target\debug\fake";

    set_up_fern().ok()?;

    if ISDEBUG {
        info!("setting up logging")
    };

    std::fs::remove_dir_all(BPATH).ok()?;
    std::fs::create_dir(BPATH).ok()?;
    std::thread::spawn(|| {
        static PREVIOUS: Mutex<Option<(Library, String)>> = Mutex::new(None);

        static PID: AtomicI8 = AtomicI8::new(0);
        let mut watcher =
            notify::recommended_watcher(|x: Result<notify::Event, notify::Error>| unsafe {
                //pure chaos, due to the file locking "itself", will need to fix
                if let Ok(x) = x {
                    if !x.kind.is_modify() || x.kind.is_create() {
                        return;
                    }
                }

                if ISDEBUG {
                    info!("file change, reloading dll")
                };

                let nextidx = PID.load(Relaxed);
                PID.store(nextidx + 1, Relaxed);

                if let Some((lib, file)) = PREVIOUS.lock().unwrap().take() {
                    let func: libloading::Symbol<unsafe extern "C" fn() -> ()> =
                        lib.get(b"cleanup").unwrap();
                    func();
                    lib.close().unwrap();
                    let _ = std::fs::remove_dir(file);
                }

                let next = format!(
                    "{}{}{}.dll",
                    r"C:\Users\Giuuu\Desktop\giuroll\giuroll\target\debug\fake\giuroll",
                    nextidx,
                    std::process::id()
                );

                if let Err(_) = std::fs::copy(
                    r"C:\Users\Giuuu\Desktop\giuroll\giuroll\target\debug\true\giuroll.dll",
                    &next,
                ) {
                    info!("copy unsuccessfull");
                }

                let x = libloading::Library::new(&next);
                match x {
                    Ok(lib) => {
                        let func: libloading::Symbol<unsafe extern "C" fn() -> ()> =
                            lib.get(b"true_exec").unwrap();
                        func();
                        *PREVIOUS.lock().unwrap() = Some((lib, next));

                        if ISDEBUG {
                            info!("reload successfull")
                        };
                    }
                    Err(x) => {
                        if ISDEBUG {
                            info!("reload unsuccessfull{:?}", x);
                        };
                    }
                }
            })
            .unwrap();

        // Add a path to be watched. All files and directories at that path and
        // below will be monitored for changes.
        watcher
            .watch(
                Path::new(r"C:\Users\Giuuu\Desktop\giuroll\giuroll\target\debug\true"),
                RecursiveMode::NonRecursive,
            )
            .unwrap();

        std::mem::forget(watcher)
    });

    //let lib = libloading::Library::new(
    //    r"C:\Users\Giuuu\Desktop\giuroll\giuroll\target\debug\giuroll.dll",
    //)
    //.unwrap();
    //let func: libloading::Symbol<unsafe extern "C" fn() -> u32> = lib.get(b"my_func").unwrap();

    /* 0x407e30*/
    //std::mem::forget();
    Some(())
}
static HOOK: Mutex<Option<Box<[HookPoint]>>> = Mutex::new(None);

static A_COUNT: AtomicI32 = AtomicI32::new(0);
static B_COUNT: AtomicI32 = AtomicI32::new(0);
static C_COUNT: AtomicI32 = AtomicI32::new(0);

#[no_mangle]
pub extern "cdecl" fn Initialize() -> bool {
    //std::thread::sleep(Duration::from_millis(2000));
    //let m = init(0);
    truer_exec();
    true
}
//687040 true real input buffer manipulation
// 85b8ec some related varible, 487040
#[no_mangle]
pub extern "cdecl" fn CheckVersion(a: *const [u8; 16]) -> bool {
    const HASH110A: [u8; 16] = [
        0x26, 0x8a, 0xfd, 0x82, 0x76, 0x90, 0x3e, 0x16, 0x71, 0x6c, 0x14, 0x29, 0xc6, 0x95, 0x9c,
        0x9d,
    ];

    const HASH110: [u8; 16] = [
        0xdf, 0x35, 0xd1, 0xfb, 0xc7, 0xb5, 0x83, 0x31, 0x7a, 0xda, 0xbe, 0x8c, 0xd9, 0xf5, 0x3b,
        0x2e,
    ];
    unsafe { *a == HASH110 }
}

#[no_mangle]
pub extern "cdecl" fn true_exec() {
    truer_exec();
}

static mut REAL_INPUT: Option<[bool; 10]> = None;
static mut REAL_INPUT2: Option<[bool; 10]> = None;

static mut UPDATE: Option<SystemTime> = None;
static mut TARGET: Option<u128> = None;

static TARGET_OFFSET: AtomicI32 = AtomicI32::new(0);
static TARGET_OFFSET_COUNT: AtomicI32 = AtomicI32::new(0);

fn truer_exec() {
    std::panic::set_hook(Box::new(|x| info!("panic! {:?}", x)));

    //info!("{:?}", dec);

    unsafe {
        FTIME = Some(DashMap::new());
        FRAME_TIMES = Some(DashMap::new());
        UNCONFIRMS = Some(DashSet::new());
    }
    DISABLE_INPUT.store(0, Relaxed);

    let (s, r) = std::sync::mpsc::channel();
    unsafe {
        DATA_RECEIVER = Some(r);
        DATA_SENDER = Some(s);
    }

    let _ = set_up_fern();
    if ISDEBUG {
        info!("true_exec ran, or did it")
    };

    unsafe {
        if ISDEBUG {
            info!("moutain_vapor: {}", *(0x8971C0 as *const usize))
        }
    };

    unsafe {
        if false {
            let funniest = 0x89ffbe;

            let mut b = PAGE_PROTECTION_FLAGS(0);
            VirtualProtect(
                0x454dad as *const c_void,
                0xc,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b,
            );
            VirtualProtect(
                0x454dcf as *const c_void,
                10,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b,
            );
            VirtualProtect(
                0x454d73 as *const c_void,
                6,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b,
            );

            *(0x454dad as *mut u32) = 0x90909090;
            *(0x454db1 as *mut u32) = 0x90909090;
            *(0x454db5 as *mut u32) = 0x90909090;
            *(0x454dcf as *mut u32) = 0x90909090;
            *(0x454dd3 as *mut u32) = 0x90909090;
            *(0x454dd7 as *mut u16) = 0x9090;
            *(0x454d73 as *mut u32) = 0x90909090;
            *(0x454d77 as *mut u16) = 0x9090;

            let funnyaddr = 0x858b80;

            VirtualProtect(
                funnyaddr as *const c_void,
                1,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b as *mut PAGE_PROTECTION_FLAGS,
            );
            *(funnyaddr as *mut u8) = 0x64;
            //8985e8 maybe effect manager please I beg
            let funnyaddr = 0x401d68;
            let mut b = PAGE_PROTECTION_FLAGS(0);

            VirtualProtect(
                funnyaddr as *const c_void,
                2, //sokuroll does 2 no idea why
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b as *mut PAGE_PROTECTION_FLAGS,
            );
            *(funnyaddr as *mut u8) = 0xeb;
            let funnyaddr = 0x47e1d0;
            let mut b = PAGE_PROTECTION_FLAGS(0);

            VirtualProtect(
                funnyaddr as *const c_void,
                1,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b as *mut PAGE_PROTECTION_FLAGS,
            );
            *(funnyaddr as *mut u8) = 0xc3;

            let funnyaddr = 0x43b120;
            let mut b = PAGE_PROTECTION_FLAGS(0);

            VirtualProtect(
                funnyaddr as *const c_void,
                1,
                PAGE_PROTECTION_FLAGS(0x40),
                &mut b as *mut PAGE_PROTECTION_FLAGS,
            );

            *(funnyaddr as *mut u8) = 0xc3;
        }
    }

    let new = unsafe {
        ilhook::x86::Hooker::new(
            0x482701, // 0x482820, //0x482532, sokuroll <-
            HookType::JmpBack(goodhook),
            ilhook::x86::CallbackOption::None,
            00,
            HookFlags::empty(),
        )
        .hook()
    }
    .unwrap();

    let mut hook = vec![new];
    //0x82251e

    // on exit

    unsafe extern "cdecl" fn onexit(a: *mut ilhook::x86::Registers, _b: usize) {
        //OP_INPUTS.lock().unwrap().clear();
        SELF_INPUTS.clear();
        UNCONFIRMS.as_ref().unwrap().clear();
        LEASTCONFIRM.store(0, Relaxed);

        //RAW_SELF.lock().unwrap().clear();
        //RAW_OTHER.lock().unwrap().clear();
        //ROLLBACK_TARGETS.lock().unwrap().clear();
        DISABLE_SEND.store(0, Relaxed);

        FRAME_TIMES.as_ref().unwrap().clear();
        FTIME.as_ref().unwrap().clear();

        // it cannot be used by any different thread now
        if let Some(x) = NTC.take() {
            DATA_RECEIVER = Some(x.consumer);
        }

        //OP_UPDATE.store(0, Relaxed);
    }

    let new = unsafe {
        ilhook::x86::Hooker::new(
            0x481960, // 0x482820, //0x482532, sokuroll <-
            HookType::JmpBack(onexit),
            ilhook::x86::CallbackOption::None,
            00,
            HookFlags::empty(),
        )
        .hook()
    }
    .unwrap();
    hook.push(new);

    for a in [0x821730, 0x821759, 0x82251e, 0x82f09e, 0x82f18c] {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                a,
                //HookType::JmpBack(freeoverride),
                HookType::JmpToAddr(a, 0xc, freeoverrideskip),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    //big source of problems 0x47d6f0

    for b in [0x821704, 0x8230e6, 0x823397, 0x82ed84, 0x82f15b] {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                b + 6,
                HookType::JmpBack(allochook),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }
    let s = 0x82246d; //0x822465; /*this one is speccial, it's called a frame before so we don't know the heap, but it's constant and it's 0x89b404 */
    {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                s,
                HookType::JmpBack(allochook2),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    for c in [0x82346f, 0x8233ee, 0x82f125] {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                c,
                HookType::JmpBack(reallochook),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    //prevent A pause
    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x482675,
                HookType::JmpBack(apause),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4133f8, //0x41df86,
                HookType::JmpBack(readframeskip),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    //{
    //    let new = unsafe {
    //        ilhook::x86::Hooker::new(
    //            0x41def8, //0x41df86,
    //            HookType::JmpBack(readframeskip2),
    //            ilhook::x86::CallbackOption::None,
    //            0,
    //            HookFlags::empty(),
    //        )
    //        .hook()
    //    }
    //    .unwrap();
    //    hook.push(new);
    //}

    // !!!!!!!!!!!!!!!!!!!!!! 00428358 calls function checking if there is a next frame in net object

    {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x41daea, //0x454f1f maybethebuffer, //0x454eba,//0x454e44, //0x41df86,
                HookType::JmpBack(readonlinedata),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    if false {
        //455960 some input buffer stuff
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x455960,
                HookType::JmpBack(readbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    if false {
        //455960 some input buffer stuff
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x407dec, //0x407f14,
                HookType::JmpBack(highloop),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    {
        unsafe extern "cdecl" fn set_eax_to_0(a: *mut ilhook::x86::Registers, _b: usize) {
            (*a).eax = *(0x8a0040 as *const u32);
        }

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x407f1b, //0x407f14,
                HookType::JmpBack(set_eax_to_0),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    unsafe extern "cdecl" fn read_pseudoraw_input(
        a: *mut ilhook::x86::Registers,
        _b: usize,
        _c: usize,
    ) {
        //        0046c902 8b ae 6c        MOV        EBP,dword ptr [ESI + 0x76c]
        //        07 00 00

        (*a).ebp = *(((*a).esi + 0x76c) as *const u32);

        //        *(((*a).esi + 0x64) as *mut u8) = 0;

        //info!("{}", (*a).edx);
        //edx 46c900 = 40A370
        //info!("here");
        //return;
        //input manager is in ecx
        let m = (*a).ecx;
        //info!("input buffer: {:?}", std::slice::from_raw_parts(m as *const u32, 0x40));

        let real_input = match std::mem::replace(&mut REAL_INPUT, REAL_INPUT2.take()) {
            Some(x) => x,
            None => {
                let f = std::mem::transmute::<usize, extern "fastcall" fn(u32)>(0x40a1a0);
                (f)(m);
                return;
                //let mut b = [false; 10];
                //b[0] = true;
                //b
            }
        };
        //*((m + 0x62) as *mut u16) = u16::MAX;
        //info!("hir {:?}", real_input);
        {
            let td = &mut *((m + 0x38) as *mut i32);
            let lr = &mut *((m + 0x3c) as *mut i32);

            match (real_input[0], real_input[1]) {
                (false, true) => *lr = (*lr).max(0) + 1,
                (true, false) | (true, true) => *lr = (*lr).min(0) - 1,
                _ => *lr = 0,
            }

            match (real_input[2], real_input[3]) {
                (false, true) => *td = (*td).max(0) + 1,
                (true, false) | (true, true) => *td = (*td).min(0) - 1,
                _ => *td = 0,
            }
        }

        for a in 0..6 {
            let v = &mut *((m + 0x40 + a * 4) as *mut u32);
            // 3: right
            //
            if real_input[a as usize + 4] {
                *v += 1;
            } else {
                *v = 0;
            }
        }

        let m = &mut *((m + 0x62) as *mut u16);
        *m = 0;
        for a in 0..10 {
            if real_input[a] {
                *m += 1 << a;
            }
        }
        //info!(
        //    "input buffer: {:?}",
        //    std::slice::from_raw_parts(m as *const u32, 0x40)
        //);

        //lr

        //info!("ecx num: {}", m + 3c)
    }
    //skip raw data read
    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x40a45d,
                HookType::JmpToAddr(0x40a462 - 5, 0, read_pseudoraw_input),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    if true {
        //return: 0x42839a
        //online input loop,

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x428374,
                HookType::JmpToAddr(0x42837f - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        unsafe extern "cdecl" fn skiponcehost(
            a: *mut ilhook::x86::Registers,
            _b: usize,
            _c: usize,
        ) -> usize {
            //info!("esi: {}", {(*a).esi});
            let skip = DISABLE_SEND.load(Relaxed) != 0;
            DISABLE_SEND.store(1, Relaxed);

            //let skip = true;

            if skip {
                0x428360
            } else {
                (*a).ecx = *(((*a).edi + 0x8) as *const u32);
                (*a).eax = *(((*a).ecx) as *const u32);
                0x428335
            }
        }

        //input 00428341
        /*
        00481980 hm
         */
        let new = unsafe {
            ilhook::x86::Hooker::new(
                /*0x4282f2, */ 0x428330,
                //HookType::JmpToAddr(0x428360 - 5, 0, skipbuffer),
                HookType::JmpToRet(skiponcehost),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        unsafe extern "cdecl" fn skiponceclient(
            a: *mut ilhook::x86::Registers,
            _b: usize,
            _c: usize,
        ) -> usize {
            let skip = DISABLE_SEND.load(Relaxed) != 0;
            DISABLE_SEND.store(1, Relaxed);
            //let skip = true;
            if skip {
                0x428630
            } else {
                (*a).ecx = *(((*a).edi + 0x8) as *const u32);
                (*a).eax = *(((*a).ecx) as *const u32);
                0x428605
            }
        }

        //input otherGameLoop
        let new = unsafe {
            ilhook::x86::Hooker::new(
                /*0x4285c2,*/ 0x428600,
                HookType::JmpToRet(skiponceclient),
                //HookType::JmpToAddr(0x428630 - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x428644,
                HookType::JmpToAddr(0x42864f - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        // top of the function, reading the input packet
        /*

               let new = unsafe {
                   ilhook::x86::Hooker::new(
                       0x4282f9,
                       HookType::JmpToAddr(0x428310 - 5, 0, skipbuffer),
                       ilhook::x86::CallbackOption::None,
                       0,
                       HookFlags::empty(),
                   )
                   .hook()
               }
               .unwrap();
               hook.push(new);

               let new = unsafe {
                   ilhook::x86::Hooker::new(
                       y,
                       HookType::JmpToAddr(0x4285e0 - 5, 0, skipbuffer),
                       ilhook::x86::CallbackOption::None,
                       0,
                       HookFlags::empty(),
                   )
                   .hook()
               }
               .unwrap();
               hook.push(new);

        */
    }
    //00899cf0 scene manager whatever that means
    //0x43e512 where the input is actually read!!

    // right - left, bottom - up, a, b, c, d

    unsafe extern "cdecl" fn timing_loop(a: *mut ilhook::x86::Registers, _b: usize, _c: usize) {
        let waithandle = (*a).esi; //should I even use this? :/
        let (m, target) = match UPDATE {
            Some(x) => (x, TARGET.as_mut().unwrap()),
            None => {
                let m = SystemTime::now();
                UPDATE = Some(m);
                TARGET = Some(0);
                (m, TARGET.as_mut().unwrap())
            }
        };
        let c = TARGET_OFFSET_COUNT.fetch_add(1, Relaxed);
        if c % 10 == 0 {
            TARGET_OFFSET.store(0, Relaxed);
        }

        let s = TARGET_OFFSET.load(Relaxed);
        *target += ((1_000_000 / 60) + s).max(1005) as u128;

        let cur = m.elapsed().unwrap().as_micros();
        let diff = (*target as i128 - cur as i128) - 1000; //spinning
        if diff > 1_000_000 {
            panic!("big diff {diff}");
        }

        //info!("frame diff micro diff: {}", diff);
        let ddiff = (diff / 1000) as i32;
        let ddiff = if ddiff < 0 {
            info!("frameskip {diff}");
            *target = cur + (1_000_000 / 60) as u128;
            3
        } else {
            ddiff
        };
        if ddiff > 0 {
            WaitForSingleObject(waithandle as isize, ddiff as u32);
            //while m.elapsed().unwrap().as_micros() < *target {}
        }
    }
    if true {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4192f0, //0x46c8f7,
                HookType::JmpToAddr(0x4193d7 - 6, 0, timing_loop),
                //HookType::JmpBack(write_input_to_esi),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        std::mem::forget(new);
        //hook.push(new);
    }

    if true {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x46c900, //0x46c8f7,
                HookType::JmpToAddr(0x46c908 - 8, 0, read_pseudoraw_input),
                //HookType::JmpBack(write_input_to_esi),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    /*
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x428651,
                HookType::JmpToAddr(0x428656 - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x428381,
                HookType::JmpToAddr(0x428686 - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
    hook.push(new);
    */

    //0x4131df creating all the threads here

    //0x4171cd online send

    /*

       let new = unsafe {
           ilhook::x86::Hooker::new(
               0x4171bc,
               HookType::JmpToRet(skipsend),
               ilhook::x86::CallbackOption::None,
               0,
               HookFlags::empty(),
           )
           .hook()
       }
       .unwrap();
       hook.push(new);
    */
    if false {
        unsafe extern "cdecl" fn report1(a: *mut ilhook::x86::Registers, _b: usize) {
            info!("addr: 1")
        }

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x416391,
                HookType::JmpBack(report1),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        unsafe extern "cdecl" fn report2(a: *mut ilhook::x86::Registers, _b: usize) {
            info!("addr: 2")
        }

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4162b5,
                HookType::JmpBack(report2),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        unsafe extern "cdecl" fn report3(a: *mut ilhook::x86::Registers, _b: usize) {
            info!("addr: 3")
        }

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x415c7f,
                HookType::JmpBack(report3),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }
    if false {
        static mut ST: Option<SystemTime> = None;
        unsafe { ST = Some(SystemTime::now()) };

        unsafe extern "cdecl" fn report_start(a: *mut ilhook::x86::Registers, _b: usize) {
            // *(0x89ffb9 as *mut u8) = 1;

            let netmanager = *(0x8986a0 as *const usize);
            if !(netmanager != 0 && *(netmanager as *const usize) != 0x858cac) {
                ST = Some(SystemTime::now());
                info!("started ",)
            }
        }

        unsafe extern "cdecl" fn reporttime(a: *mut ilhook::x86::Registers, _b: usize) {
            let netmanager = *(0x8986a0 as *const usize);
            if !(netmanager != 0 && *(netmanager as *const usize) != 0x858cac) {
                if let Some(st) = ST {
                    info!(
                        "timeelapsed: {} {:0x}",
                        st.elapsed().unwrap().as_millis(),
                        _b
                    )
                } else {
                    info!("BEFORE");
                }
            }
        }
        //00407cba insanely important

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x407e26,
                HookType::JmpBack(report_start),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        //0x4285c4 0x4285e0

        // 0x407f21 WAS REACHED
        // f89 WAS REACHED
        //0x407f3a
        //[0x407e33, 0x407e9e, 0x407f21, 0x407f2c, 0x407f89, 0x407f98, 0x407f9d, 0x407f3c, 0x407fc6, 0x407f2c, 0x407f3c, 0x407f66]
        /*
        [
            0x454760, 0x4547c0, 0x4549a0, 0x454800, 0x43fcc0, 0x43f950, 0x454640, 0x455340,
            0x455070, 0x454910, 0x455180, 0x454c90, 0x454d30, 0x454a40, 0x454860, 0x43fc20,
            0x43fc30, 0x454950, 0x43fc40, 0x4546a0, 0x4546c0,
            ]
            */
        for a in [
            0x407e33, 0x407ea4, 0x407f14, 0x408005, 0x408031, 0x419687, 0x41968d, 0x40803b,
            0x4192f0, 0x4193dc, 0x4193a2,
        ] {
            let new = unsafe {
                ilhook::x86::Hooker::new(
                    a,
                    HookType::JmpBack(reporttime),
                    ilhook::x86::CallbackOption::None,
                    a,
                    HookFlags::empty(),
                )
                .hook()
            }
            .unwrap();
            hook.push(new);
        }
    }

    unsafe extern "cdecl" fn reportedx(a: *mut ilhook::x86::Registers, _b: usize) {
        let netmanager = *(0x8986a0 as *const usize);
        let is_main = netmanager != 0 && *(netmanager as *const usize) == 0x858cac;
        if netmanager != 0 && *(netmanager as *const usize) != 0x858cac {
            //(*a).edx = 0x41F820;
            //if (*a).edx == 0x454860 {
            //    (*a).edx = 0x4556F0;
            //}
        }
        info!("edx: {} is main: {is_main} {_b}", (*a).edx);
    }

    unsafe extern "cdecl" fn log_gametype(a: *mut ilhook::x86::Registers, _b: usize) {
        info!("GAMETYPE TRUE {}", *(0x89868c as *const usize));
    }

    let new = unsafe {
        ilhook::x86::Hooker::new(
            0x43e5fb,
            HookType::JmpBack(log_gametype),
            ilhook::x86::CallbackOption::None,
            0,
            HookFlags::empty(),
        )
        .hook()
    }
    .unwrap();
    hook.push(new);

    if false {
        unsafe extern "cdecl" fn zeroouteax(
            a: *mut ilhook::x86::Registers,
            _b: usize,
            _c: usize,
        ) -> usize {
            (*a).eax = 1;
            0x4546bd
        }

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4546a0,
                HookType::JmpToRet(zeroouteax),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }
    // one of the functions that blocks on frame 1
    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x42828f,
                HookType::JmpToAddr(0x4282a5 - 5, 0, skipbuffer),
                ilhook::x86::CallbackOption::None,
                0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }

    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4285d2,
                HookType::JmpBack(reportedx),
                ilhook::x86::CallbackOption::None,
                0x4285d2,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4285e0,
                HookType::JmpBack(reportedx),
                ilhook::x86::CallbackOption::None,
                0x4285e0,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();

        hook.push(new);
    }
    /*

      let new = unsafe {
          ilhook::x86::Hooker::new(
              0x428200,
              HookType::JmpToAddr(0x4282be - 5, 0, skipbuffer),
              ilhook::x86::CallbackOption::None,
              0,
              HookFlags::empty(),
          )
          .hook()
      }
      .unwrap();
      hook.push(new);
    */

    // 428200 gets stuck here !!!!
    // [2023-05-21T09:06:08.998053500Z INFO giuroll] edx: 4323360 is main: false v player V PRACTICE ! V CPU

    //[2023-05-21T09:07:30.302946700Z INFO giuroll] edx: 4358656 is main: false  online, BOTH players, only client gets stuck

    // interesting function inspecting the packets 428200

    //client edx 0x454860
    // host edx 0x4556F0

    /*
                                 **************************************************************
                                 * const CNetworkServer::vftable                              *
                                 **************************************************************
                                 CNetworkServer::vftable                         XREF[2]:     FUN_0043fa20:0043fa6e(*),
                                                                                              FUN_0043fb10:0043fb3e(*)
            00858c8c e0 db 43        addr[6]
                     00 20 f8
                     41 00 c0
               00858c8c e0 db 43 00     addr      FUN_0043dbe0            [0]                               XREF[2]:     FUN_0043fa20:0043fa6e(*),
                                                                                                                         FUN_0043fb10:0043fb3e(*)
               00858c90 20 f8 41 00     addr      FUN_0041f820            [1]
               00858c94 c0 fa 43 00     addr      FUN_0043fac0            [2]
               00858c98 00 5b 45 00     addr      NETPLAYTWOOQUESTIONMARK [3]
               00858c9c c0 55 45 00     addr      FUN_004555c0            [4]
    **00858ca0 20 f8 41 00     addr      FUN_0041f820            [5]
            00858ca4 00 00 00 00     addr       00000000                                         terminator for class CNetworkSer
                                 **************************************************************
                                 * meta pointer for CNetworkServer::vftable                   *
                                 **************************************************************
                                 CNetworkServer::vftable_meta_ptr
            00858ca8 0c 26 87 00     addr       CNetworkServer::RTTI_Complete_Object_Locator
                                 **************************************************************
                                 * const CNetworkServer::vftable                              *
                                 **************************************************************
                                 CNetworkServer::vftable                         XREF[2]:     FUN_0043fa20:0043fa68(*),
                                                                                              FUN_0043fb10:0043fb38(*)
            00858cac 80 fb 43        addr[17]
                     00 d0 fa
                     43 00 40
               00858cac 80 fb 43 00     addr      FUN_0043fb80            [0]                               XREF[2]:     FUN_0043fa20:0043fa68(*),
                                                                                                                         FUN_0043fb10:0043fb38(*)
               00858cb0 d0 fa 43 00     addr      FUN_0043fad0            [1]
               00858cb4 40 5d 45 00     addr      FUN_00455d40            [2]
               00858cb8 c0 5f 45 00     addr      FUN_00455fc0            [3]
               00858cbc 00 5e 45 00     addr      FUN_00455e00            [4]
               00858cc0 a0 57 45 00     addr      FUN_004557a0            [5]
               00858cc4 70 5f 45 00     addr      FUN_00455f70            [6]
               00858cc8 60 59 45 00     addr      FUN_00455960            [7]
               00858ccc f0 58 45 00     addr      FUN_004558f0            [8]
               00858cd0 a0 58 45 00     addr      FUN_004558a0            [9]
               00858cd4 f0 56 45 00     addr      FUN_004556f0            [10]
               00858cd8 90 fa 43 00     addr      FUN_0043fa90            [11]
               00858cdc a0 fa 43 00     addr      FUN_0043faa0            [12]
               00858ce0 10 55 45 00     addr      FUN_00455510            [13]
               00858ce4 b0 fa 43 00     addr      FUN_0043fab0            [14]
               00858ce8 e0 54 45 00     addr      FUN_004554e0            [15]
               00858cec f0 57 45 00     addr      FUN_004557f0            [16]




                                 **************************************************************
                                 * meta pointer for CNetworkClient::vftable                   *
                                 **************************************************************
                                 CNetworkClient::vftable_meta_ptr
            00858cf0 dc 26 87 00     addr       CNetworkClient::RTTI_Complete_Object_Locator
                                 **************************************************************
                                 * const CNetworkClient::vftable                              *
                                 **************************************************************
                                 CNetworkClient::vftable                         XREF[2]:     FUN_0043fba0:0043fbee(*),
                                                                                              FUN_0043fc50:0043fc84(*)
            00858cf4 60 47 45        addr[6]
                     00 c0 47
                     45 00 00
               00858cf4 60 47 45 00     addr      FUN_00454760            [0]                               XREF[2]:     FUN_0043fba0:0043fbee(*),
                                                                                                                         FUN_0043fc50:0043fc84(*)
               00858cf8 c0 47 45 00     addr      FUN_004547c0            [1]
               00858cfc 00 4e 45 00     addr      ACTUALLYHANDLEINPUT     [2]
               00858d00 a0 49 45 00     addr      FUN_004549a0            [3]
               00858d04 00 48 45 00     addr      FUN_00454800            [4]
    *00858d08 20 f8 41 00     addr      FUN_0041f820            [5]
            00858d0c 00 00 00 00     addr       00000000                                         terminator for class CNetworkCli
                                 **************************************************************
                                 * meta pointer for CNetworkClient::vftable                   *
                                 **************************************************************
                                 CNetworkClient::vftable_meta_ptr
            00858d10 8c 26 87 00     addr       CNetworkClient::RTTI_Complete_Object_Locator
                                 **************************************************************
                                 * const CNetworkClient::vftable                              *
                                 **************************************************************
                                 CNetworkClient::vftable                         XREF[2]:     FUN_0043fba0:0043fbe8(*),
                                                                                              FUN_0043fc50:0043fc7e(*)
            00858d14 c0 fc 43        addr[17]
                     00 50 f9
                     43 00 40
               00858d14 c0 fc 43 00     addr      FUN_0043fcc0            [0]                               XREF[2]:     FUN_0043fba0:0043fbe8(*),
                                                                                                                         FUN_0043fc50:0043fc7e(*)
               00858d18 50 f9 43 00     addr      FUN_0043f950            [1]
               00858d1c 40 46 45 00     addr      FUN_00454640            [2]
               00858d20 40 53 45 00     addr      FUN_00455340            [3]
               00858d24 70 50 45 00     addr      FUN_00455070            [4]
               00858d28 10 49 45 00     addr      FUN_00454910            [5]
               00858d2c 80 51 45 00     addr      FUN_00455180            [6]
               00858d30 90 4c 45 00     addr      FUN_00454c90            [7]
               00858d34 30 4d 45 00     addr      FUN_00454d30            [8]
               00858d38 40 4a 45 00     addr      FUN_00454a40            [9]
               00858d3c 60 48 45 00     addr      FUN_00454860            [10]
               00858d40 20 fc 43 00     addr      FUN_0043fc20            [11]
               00858d44 30 fc 43 00     addr      FUN_0043fc30            [12]
               00858d48 50 49 45 00     addr      FUN_00454950            [13]
               00858d4c 40 fc 43 00     addr      FUN_0043fc40            [14] // crash candidate #1, it returns a slightly different value than server variant so unlikely
               00858d50 a0 46 45 00     addr      FUN_004546a0            [15] //crash candidate #2, this one actually does something
               00858d54 c0 46 45 00     addr      FUN_004546c0            [16]




     */

    if false {
        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4548a1,
                HookType::JmpBack(reportedx),
                ilhook::x86::CallbackOption::None,
                2,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);

        let new = unsafe {
            ilhook::x86::Hooker::new(
                0x4548ef,
                HookType::JmpBack(reportedx),
                ilhook::x86::CallbackOption::None,
                1,
                HookFlags::empty(),
            )
            .hook()
        }
        .unwrap();
        hook.push(new);
    }
    /*

    unsafe extern "cdecl" fn overwrite_ebx(a: *mut ilhook::x86::Registers, _b: usize) {
        (*a).ebx = 1;
    }

    let new = unsafe {
        ilhook::x86::Hooker::new(
            0x4548e9,
            HookType::JmpBack(overwrite_ebx),
            ilhook::x86::CallbackOption::None,
            1,
            HookFlags::empty(),
        )
        .hook()
    }
    .unwrap();
    hook.push(new);

    0x857570 yet another vtable
     */

    //let new = unsafe {
    //    ilhook::x86::Hooker::new(
    //        0x454865,
    //        HookType::JmpToAddr(0x4548fe-5, 0, skipbuffer),
    //        ilhook::x86::CallbackOption::None,
    //        0,
    //        HookFlags::empty(),
    //    )
    //    .hook()
    //}
    //.unwrap();
    //hook.push(new);

    //[2023-05-20T19:52:49.531014600Z INFO giuroll] panic! PanicInfo { payload: Any { .. }, message: Some(requested frame: 110, accessible were: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 111]), location: Location { file: "src\\lib.rs", line: 2573, col: 21 }, can_unwind: true }

    //let new = unsafe {
    //    ilhook::x86::Hooker::new(
    //        0x42cf90,
    //        HookType::JmpToAddr(0x42d004 - 5, 0, skipbuffer),
    //        ilhook::x86::CallbackOption::None,
    //        0,
    //        HookFlags::empty(),
    //    )
    //    .hook()
    //}
    //.unwrap();
    //hook.push(new);

    // somewhere here something related to online is set ugh

    // this function actually sets up input, I might as well just not touch it for the time being
    // 00416C88 - C6 46 1C 0E - mov byte ptr [esi+1C],0E writes to packet

    //004171cd true candidate 1?

    //true candidate 1: 0041745c

    //candidate 1: 41745c, 2: 4173AF 3: 416391 4: 4162b5 .. a lot here ...  415d41: init_success 415c7f: 0xa? unknown code 415ad8: unknown also
    //not :41745c -> called every 0.5 sec proabably host only, 4173AF equivalent client only

    //415ad8 hasn't been called yet
    //

    // none of these 3 either : 0x416391 0x4162b5 these two init
    // this one hasn't been called: 0x415c7f

    //opponent netcode input 0x46c8e0

    //40a370

    //player 2 input override 0x40a370
    //player 1 input override 0x40a1a0
    //let new = unsafe {
    //    ilhook::x86::Hooker::new(
    //        0x40a256,
    //        HookType::JmpToAddr(0x40a310 - 5, 0, skipbuffer),
    //        ilhook::x86::CallbackOption::None,
    //        0,
    //        HookFlags::empty(),
    //    )
    //    .hook()
    //}
    //.unwrap();
    //hook.push(new);

    //let new = unsafe {
    //    ilhook::x86::Hooker::new(
    //        0x43e50d,
    //        HookType::JmpToRet(skipinput),
    //        ilhook::x86::CallbackOption::None,
    //        0,
    //        HookFlags::empty(),
    //    )
    //    .hook()
    //}
    //.unwrap();
    //hook.push(new);

    //0x4558a0 check for next frame
    /*let new = unsafe {
        ilhook::x86::Hooker::new(
            0x428374, //0x428351,
            HookType::JmpToAddr(0x42837f - 5, 0, skipbuffer2),
            ilhook::x86::CallbackOption::None,
            0,
            HookFlags::empty(),
        )
        .hook()
    }
    .unwrap();
    hook.push(new);*/

    *HOOK.lock().unwrap() = Some(hook.into_boxed_slice());
}

#[no_mangle]
pub extern "cdecl" fn cleanup() {
    if ISDEBUG {
        info!("cleaning up the hook")
    };

    for a in std::mem::replace(&mut *FRAMES.lock().unwrap(), Vec::new()) {
        a.did_happen();
    }

    HOOK.lock()
        .unwrap()
        .take()
        .unwrap()
        .into_vec()
        .into_iter()
        .for_each(|x| unsafe { x.unhook() }.unwrap());
}

unsafe fn set_input_buffer(
    /*input_manager: usize, input: [bool; 10] */ input: [bool; 10],
    input2: [bool; 10],
) {
    //let vtable = *(input_manager as *const usize);
    // let loadbuff = std::mem::transmute::<usize, extern "fastcall" fn(usize)>(vtable /* + 4 */);
    REAL_INPUT = Some(input);
    REAL_INPUT2 = Some(input2);
    //let loadbuff =
    //    std::mem::transmute::<usize, extern "fastcall" fn(usize)>(0x40a370 /* + 4 */);
    //loadbuff(input_manager);
}

/*
a type 1 object has a layout of
    void* start,
    undef4 unk,
    void* end,
    undef4??, //not sure if this exists or not

a type 2 object has a layout like this:
    type3* a
    undef 4 unk
    void ** attached

a type3 object, possibly an array has a layout like this:
    undef12*
*/

const SOKU_FRAMECOUNT: *mut usize = 0x8985d8 as *mut usize;

unsafe extern "cdecl" fn freeoverride(_a: *mut ilhook::x86::Registers, _b: usize) {
    //let heap = *(((*_a).esp as usize + 0 * 4) as *mut usize);
    //info!("hpea: {heap}");

    let s = ((*_a).esp as usize + 2 * 4) as *mut usize;
    let mut f = FRAMES.lock().unwrap();

    match f.last_mut() {
        Some(x) => {
            x.frees.push(*s);
            unsafe { *s = 0 };
        }
        None => (), //ignore
    }

    A_COUNT.store(A_COUNT.load(Relaxed) + 1, Relaxed);

    //unsafe { (*a).esp = 0x12 + (*a).esp }
    //unsafe { (*a).esp = 0x420 }
    //unsafe { (*a).eax = 0x66 }

    //
    //for idx in 0..3 {
    //    unsafe {
    //
    //        if idx == 2 {
    //            //*s = 0;
    //        }
    //    }
    //}th123.exe+422523 - 00 85 C07516E8        - add [ebp-17E98A40],al
    //th123.exe+422524 - 85 C0                 - test eax,eax
    //th123.exe+422526 - 75 16                 - jne th123.exe+42253E
}

unsafe extern "cdecl" fn freeoverrideskip(_a: *mut ilhook::x86::Registers, _b: usize, _c: usize) {
    //let heap = *(((*_a).esp as usize + 0 * 4) as *mut usize);
    //info!("hpea: {heap}");

    (*_a).eax = 1;
    let s = ((*_a).esp as usize + 2 * 4) as *mut usize;
    //info!("{}", *s);
    let mut f = FRAMES.lock().unwrap();

    match f.last_mut() {
        Some(x) => {
            x.frees.push(*s);
            //unsafe { *s = 0 };
        }
        None => (), //ignore
    }

    A_COUNT.store(A_COUNT.load(Relaxed) + 1, Relaxed);

    //unsafe { (*a).esp = 0x12 + (*a).esp }
    //unsafe { (*a).esp = 0x420 }
    //unsafe { (*a).eax = 0x66 }

    //
    //for idx in 0..3 {
    //    unsafe {
    //
    //        if idx == 2 {
    //            //*s = 0;
    //        }
    //    }
    //}th123.exe+422523 - 00 85 C07516E8        - add [ebp-17E98A40],al
    //th123.exe+422524 - 85 C0                 - test eax,eax
    //th123.exe+422526 - 75 16                 - jne th123.exe+42253E
}

fn store_alloc(u: usize) {
    match FRAMES.lock().unwrap().last_mut() {
        Some(x) => x.allocs.push(u),
        None => (), //happened for sure
    }
}

unsafe extern "cdecl" fn allochook(a: *mut ilhook::x86::Registers, _b: usize) {
    let (s, heap) = unsafe {
        (
            *(((*a).esp as usize + 2 * 4) as *mut usize),
            *(((*a).esp as usize + 1 * 4) as *mut usize),
        )
    };

    store_alloc(s);
    B_COUNT.store(B_COUNT.load(Relaxed) + 1, Relaxed);
}

unsafe extern "cdecl" fn allochook2(a: *mut ilhook::x86::Registers, _b: usize) {
    //let s = unsafe { *(((*a).esp as usize + 1 * 4) as *mut usize) };

    let ptr = unsafe { (*a).eax };
    store_alloc(ptr as usize);

    B_COUNT.store(B_COUNT.load(Relaxed) + 1, Relaxed);
}
#[allow(unused)]
unsafe extern "cdecl" fn reallochook(a: *mut ilhook::x86::Registers, _b: usize) {
    C_COUNT.store(C_COUNT.load(Relaxed) + 1, Relaxed);

    //for some reason sokuroll allows realocation, so will I :)
    /*
    {
        let (flags, addr, size): (*mut usize, *mut usize, *mut usize) = unsafe {
            (
                (((*a).esp as usize + 1 * 4) as *mut usize),
                (((*a).esp as usize + 2 * 4) as *mut usize),
                (((*a).esp as usize + 3 * 4) as *mut usize),
            )
        };

        if ISDEBUG {
            info!("addr {} size {}", *addr, *size)
        };
        let oldsize = read_heap(*addr);

        let w = HeapAlloc(
            *(0x89b404 as *const HeapHandle),
            std::mem::transmute(*flags as u32),
            oldsize,
        ) as *mut u8;

        std::slice::from_raw_parts_mut(w, oldsize)
            .copy_from_slice(std::slice::from_raw_parts_mut(addr as *mut u8, oldsize));

        let w = w as usize;
        if ISDEBUG {
            info!("success {} {} oldsize", w, oldsize)
        };
        *addr = w;

        if ISDEBUG {
            info!("success")
        };
    }
    */
}

use core::sync::atomic::AtomicU8;
use std::arch::asm;

static LAST_STATE: AtomicU8 = AtomicU8::new(0x69);

fn pause(battle_state: &mut u32) {
    if *battle_state != 4 {
        LAST_STATE.store(*battle_state as u8, Relaxed);
        *battle_state = 4;
    }
}
fn resume(battle_state: &mut u32) {
    let last = LAST_STATE.load(Relaxed);
    if last != 0x69 {
        *battle_state = last as u32;
        LAST_STATE.store(0x69, Relaxed)
    }
}

static GOOF: AtomicU8 = AtomicU8::new(0);

static PAUSESTATE: AtomicU8 = AtomicU8::new(0);
// game type :0x898688, practice : 2
// replay input: 0x89a248

unsafe extern "cdecl" fn apause(a: *mut ilhook::x86::Registers, _b: usize) {
    //let pinput = 0x89a248;
    //let input = read_addr(0x89a248, 0x58).usize_align();
    let pstate = PAUSESTATE.load(Relaxed);

    const ABUTTON: *mut usize = (0x89a248 + 0x40) as *mut usize;
    let a_input = *ABUTTON;
    *ABUTTON = 0;
    match (a_input, pstate) {
        (0, 1) => PAUSESTATE.store(2, Relaxed),
        (0, _) => (),
        (1, 0) => PAUSESTATE.store(1, Relaxed),
        (1, 1) => (),
        (1, 2) => PAUSESTATE.store(0, Relaxed),
        _ => (),
    }
    //if ISDEBUG { info!("input: {:?}", input[16]) };
}

unsafe extern "cdecl" fn readframeskip(a: *mut ilhook::x86::Registers, _b: usize) {
    let ecx = (*a).ecx;
    //let p80 = ecx + 0x80;
    //let first = *(p80 as *const usize);
    //info!("ecx: {}", ecx);
}

//0x454e00
/*0x454e00  ONLINE INPUT!!!!*/
//0x454D30 another one? called at 454ecf
unsafe extern "cdecl" fn readframeskip2(a: *mut ilhook::x86::Registers, _b: usize) {
    let ecx = (*a).eax;
    //info!("ecx: {}", ecx); 4541952
}
// net object + 0x78 is "next input"?

static mut UNCONFIRMS: Option<DashSet<usize>> = None;
static LEASTCONFIRM: AtomicU32 = AtomicU32::new(0);
/*
unsafe fn confirm_frame(num: usize) {
    //info!("confirming {num}");
    let mut buf = [0u8; 400];
    buf[0] = 0x6b;

    buf[2..6].copy_from_slice(&num.to_le_bytes());

    let netmanager = *(0x8986a0 as *const usize);

    let socket = netmanager + 0x3e4;

    //info!("nm {}", *(netmanager as *const usize));

    let to;
    if *(netmanager as *const usize) == 0x858cac {
        let it = (netmanager + 0x4c8) as *const usize;
        buf[1] = 1;
        //std::thread::sleep(Duration::from_millis(5));
        if *it == 0 {
            info!("panichere");
            panic!();
        }
        to = *(it as *const *const SOCKADDR);
    } else {
        buf[1] = 2;

        if *(netmanager as *const usize) != 0x858d14 {
            info!("panichere2");
            panic!();
        }
        to = (netmanager + 0x47c) as *const SOCKADDR
    }
    //buf[8..12].copy_from_slice(&last_rollback.to_le_bytes());

    //info!("about to send");
    let rse = sendto(*(socket as *const SOCKET), &buf, 0, to, 400);
    //info!("sent");
    if rse == -1 {
        info!("socket err: {:?}", WSAGetLastError());
    }
}
 */

static mut FTIME: Option<DashMap<usize, i32>> = None;

unsafe extern "cdecl" fn readonlinedata(a: *mut ilhook::x86::Registers, _b: usize) {
    let esp = (*a).esp;

    let packet_pointer = esp + 0x70;
    let slic = std::slice::from_raw_parts(packet_pointer as *const u8, 400);
    let type1 = slic[0];
    let type2 = slic[1];

    let frame_count = usize::from_le_bytes(slic[2..6].try_into().unwrap());
    let sceneid = slic[6];
    let somethingweird = slic[7];
    let input1 = slic[8];
    let input2 = slic[9];

    //info!(
    //    " {type1} {type2} fc: {}, count: {input1} {input2}, scene: {sceneid}, weird: {somethingweird}",
    //    frame_count,
    //);

    //info!("{type1}, {type2}");
    /*

    if type1 == 13 && type2 == 2 {
        //DISABLE_SEND.store(1, Relaxed);
    }
    if type1 == 0x6b {
        (*a).eax = 0x400;
        {
            let v = &mut CONFIRMATIONS;
            v.push(frame_count);
            let mut lastleast = LEASTCONFIRM.load(Relaxed);
            while let Some(_) = v.iter().find(|x| (**x) as u32 == lastleast) {
                lastleast += 1;
            }
            LEASTCONFIRM.store(lastleast, Relaxed);
        }
    }

    if type1 == 0x6a {
        // retime request, sent probably every 10 frames, containing the latency between the actual frame, and the received frame,
        // signed, in microseconds, averaged out, and applied to the clock... across next 10 frames?
        (*a).eax = 0x400;

        if frame_count + 50 < *SOKU_FRAMECOUNT {
            return;
        }

        let m = slic[6..46]
            .chunks(4)
            .map(|x| i32::from_le_bytes(x.try_into().unwrap()));

        let sum: i32 = m.sum();

        let ftime = &FTIME;
        if let Some(x) = (frame_count - 10..frame_count)
            .map(|x| ftime.as_ref().unwrap().get(&x).map(|x| *x))
            .collect::<Option<Vec<_>>>()
        {
            let my_sum: i32 = x.iter().sum();
            let diff: i32 = my_sum - sum;

            // how much slower were we than the oponent
            info!(
                "frame diff: {diff} {} opponent: {}, me: {}",
                frame_count, sum, my_sum,
            );
            if diff < -300_000 {
                TARGET_OFFSET_COUNT.store(1, Relaxed);
                TARGET_OFFSET.store(-1000, Relaxed);
            } else if diff > 300_000 {
                TARGET_OFFSET_COUNT.store(1, Relaxed);
                TARGET_OFFSET.store(diff / 2000, Relaxed);
            } else if diff.abs() > 100_000 {
                TARGET_OFFSET_COUNT.store(1, Relaxed);
                TARGET_OFFSET.store(diff / 4000, Relaxed);
            } else {
                TARGET_OFFSET_COUNT.store(1, Relaxed);
                TARGET_OFFSET.store(diff / 8000, Relaxed);
            }
            //if diff > 100_000 {
            //    // we are so much faster we need to frame skip
            //} else if diff < -10000 {
            //    TARGET_OFFSET.store(-3000, Relaxed);
            //} else if diff > 10000 {
            //    TARGET_OFFSET.store(3000, Relaxed);
            //}
        } else {
            //we have not gotten to the frame of the host, we are behind
        }
    }
    */
    if type1 == 0x69 {
        (*a).eax = 0x400;
        let z = NetworkPacket::decode(slic);
        for (id, input) in z.inputs.iter().enumerate() {
            let frame = z.id + z.delay as usize - id;
            let inp_a = *input;

            let inp = (0..10)
                .into_iter()
                .map(|x| (inp_a & (1 << x)) > 0)
                .collect::<Vec<_>>()
                .try_into()
                .unwrap();

            DATA_SENDER.as_mut().unwrap().send((frame, inp)).unwrap();
        }

        for (id, confirm) in z.confirms.iter().enumerate() {
            if *confirm {
                let frame = z.id + z.delay as usize - id;

                let v = UNCONFIRMS.as_ref().unwrap();
                v.remove(&frame);

                LEASTCONFIRM.store(
                    v.iter().map(|x| *x).min().unwrap_or(*SOKU_FRAMECOUNT) as u32,
                    Relaxed,
                );

                //while let Some(_) = v.iter().find(|x| (**x) as u32 == lastleast) {
                //    lastleast += 1;
                //}
                //LEASTCONFIRM.store(lastleast, Relaxed);
            } // else maybe send the packet again?
        }

        if false {
            //todo send less things through the channel
            let size = u16::from_le_bytes(slic[6..8].try_into().unwrap()) as usize;
            //info!("received frame: {frame_count}");
            for a in (0..size).rev() {
                let offset = a * 2;
                let inp_a = u16::from_le_bytes(slic[8 + offset..10 + offset].try_into().unwrap());

                let inp = (0..10)
                    .into_iter()
                    .map(|x| (inp_a & (1 << x)) > 0)
                    .collect::<Vec<_>>()
                    .try_into()
                    .unwrap();

                DATA_SENDER
                    .as_mut()
                    .unwrap()
                    .send((frame_count - a, inp))
                    .unwrap();

                if frame_count > *SOKU_FRAMECOUNT + 6
                /* max_rollback */
                {
                } else {
                    confirm_frame(frame_count - a);
                }
            }
        }

        let rmt = FTIME.as_ref().unwrap();

        if let Some(_) = rmt.get(&frame_count) {
            return;
            // we already had that one, nothing else needed
        }

        let lct = FRAME_TIMES.as_ref().unwrap();

        if let Some(x) = lct.insert(frame_count, SystemTime::now()) {
            //we are after the local frame
            lct.insert(frame_count, x);

            if let Some(_) = rmt.insert(frame_count, x.elapsed().unwrap().as_micros() as i32) {
                panic!("unreachable")
            }
        } else {
            //we are before the local frame , delay netcode
            // mark remote as already received
            if let Some(_) = rmt.insert(frame_count, 0) {
                panic!("unreachable");
            }

            // while getting here the local value has been filled out, we can use it now
        }

        //info!("received frame {frame_count} {tru}");

        //let lr = i32::from_le_bytes(slic[8..12].try_into().unwrap());
        /*
        if lr < last_rollback - 1 {
            TARGET_OFFSET.store(1000, Relaxed);
        }

        if lr > last_rollback + 1 {
            TARGET_OFFSET.store(-1000, Relaxed);
        }
        */
    }
    if (type1 == 14 || type1 == 13) && type2 == 3 && sceneid == 0x5 {
        //(*a).eax = 0x400;

        info!("received {} {}", type1, type2);
    } else {
        //
        //
        //
        //
        //
    }
}

// 43e320 HERE THE PACKET IS READ FROM TRACING THE USAGE OF PACKET MANAGER

unsafe extern "cdecl" fn readbuffer(a: *mut ilhook::x86::Registers, _b: usize) {
    let ecx = (*a).ecx;
    //info!("ecx: {:#x}", ecx);//0x3734148
}

unsafe extern "cdecl" fn highloop(a: *mut ilhook::x86::Registers, _b: usize) {
    //let ecx = (*a).eax;
    //let netmanager = *(0x8986a0 as *const usize);
    //*(netmanager as *const usize) == 0x858cac
    //info!("here {}", netmanager);
    //info!("eax: {:#x}", ecx)

    info!("here HL!");
}

static DISABLE_INPUT: AtomicU8 = AtomicU8::new(0);
static DISABLE_SEND: AtomicU8 = AtomicU8::new(0);

unsafe extern "cdecl" fn skipinput(a: *mut ilhook::x86::Registers, _b: usize, _c: usize) -> usize {
    (*a).ecx = 0x8986a8;
    if DISABLE_INPUT.load(Relaxed) == 0 {
        0x43e512
    } else {
        (*a).esi = 0;
        (*a).ebx = 0;
        0x43e520
    }
}

//interesting adress 43E363

//input: 008985e4 (battle manager) + 12 + someoffset;

unsafe extern "cdecl" fn skipbuffersleep(a: *mut ilhook::x86::Registers, _b: usize, _c: usize) {
    std::thread::sleep(Duration::from_millis(1));
}

unsafe extern "cdecl" fn skipsend(a: *mut ilhook::x86::Registers, _b: usize, _c: usize) -> usize {
    //0x4171c2; // call it
    /*
                                LAB_004171bc                                    XREF[1]:     00417199(j)
       004171bc 8b 57 18        MOV        EDX,dword ptr [EDI + 0x18]
       004171bf 8b 46 28        MOV        EAX,dword ptr [ESI + 0x28]

    */

    //0x4171d2; // skip it

    if DISABLE_SEND.load(Relaxed) != 0 {
        0x4171d2
    } else {
        (*a).edx = *(((*a).edi + 0x18) as *const u32);
        (*a).eax = *(((*a).esi + 0x28) as *const u32);

        0x4171c2
    }

    //candidate 1: 41745c, 2: 4173AF 3: 416391 4: 4162b5 .. a lot here ...  415d41: init_success 415c7f: 0xa? unknown code 415ad8: unknown also
}
unsafe extern "cdecl" fn skipbuffer(a: *mut ilhook::x86::Registers, _b: usize, _c: usize) {
    //let bm = *(0x8985e4 as *const usize);
    //let vt = *(bm as *const usize);
    //let func = *((vt+ 0xc) as *const usize);

    //if (*a).eax == 0x4282f0 {
    //    (*a).eax = 0x41e0c0;
    //}
    //(*a).ecx = bm as u32;
    //let f = std::mem::transmute::<usize, extern "fastcall" fn(usize) -> usize>(func);
    //info!("f: {}", f as usize);
    //f(bm);

    // relevant function: 0x4558a0

    //info!("eax: {:#x}", (*a).edx);
}

static LASTFR: AtomicI32 = AtomicI32::new(0);
static ENDED: AtomicI32 = AtomicI32::new(0);

unsafe fn handle_replay(
    fc2: usize,
    battle_state: &mut u32,
    cur_speed: &mut u32,
    cur_speed_iter: &mut u32,
) {
    let fc2 = *SOKU_FRAMECOUNT;
    let p = LASTFR.load(Relaxed);

    LASTFR.store(fc2 as i32, Relaxed);

    if fc2 == 0 {
        if ISDEBUG {
            info!("frame 0")
        };
        unsafe {
            if ISDEBUG {
                info!("moutain_vapor_f0: {}", *(0x8971C0 as *const usize))
            }
        };
        let w = std::mem::replace(&mut *FRAMES.lock().unwrap(), Vec::new());
        for frame in w {
            frame.did_happen();
        }
    }

    //let mystcountpos: u32;

    //0x57

    resume(battle_state);
    if PAUSESTATE.load(Relaxed) != 0 {
        pause(battle_state);
        return;
    }

    if *battle_state == 4 {
        if ISDEBUG {
            info!("HEREEXTREMELYBAD")
        };
    }

    if *cur_speed == *cur_speed_iter + 1 {
        if ISDEBUG {
            info!("end iteration")
        };
        ENDED.store(0, Relaxed);
    };

    if *cur_speed_iter == 0 {
        if p + 1 != fc2 as i32 && p != fc2 as i32 + 1 {
            if ISDEBUG {
                info!("badnextframe: {}, {}", p, fc2)
            };
        }

        if *cur_speed != 1 {
            if ISDEBUG {
                info!("cur_speed {}", *cur_speed)
            };
            //std::thread::sleep(Duration::from_millis(20));
        }

        if ISDEBUG {
            info!("begun iteration")
        };
        if ENDED.load(Relaxed) != 0 {
            if ISDEBUG {
                info!("here bait")
            };
        }
        ENDED.store(1, Relaxed);

        GOOF.store(0, Relaxed);
        //"true" frame
        let qdown = windows::Win32::UI::Input::KeyboardAndMouse::GetAsyncKeyState(0x51) != 0;
        let wdown = windows::Win32::UI::Input::KeyboardAndMouse::GetAsyncKeyState(0x57) != 0;

        if qdown {
            let target = (fc2 as u32).saturating_sub(*cur_speed) - 1;

            if ISDEBUG {
                info!("qdown {}", target)
            };

            let mutex = match FRAMES.lock() {
                Ok(x) => x,
                Err(_) => return,
            };
            let mut map = mutex;
            let frames = &mut *map;
            let mut last: Option<Frame> = None;
            loop {
                let candidate = frames.pop();
                if let Some(x) = candidate {
                    if let Some(x) = last {
                        x.never_happened();
                    }

                    let framenum = x.number as u32;
                    if framenum <= target {
                        GOOF.store(1, Relaxed);
                        //good
                        let diff = target - framenum;
                        if ISDEBUG {
                            info!("diff: {}", diff)
                        };

                        x.restore();

                        //dump_frame();
                        //unsafe {
                        //    FPST = x.fp;
                        //    asm!(
                        //        "FRSTOR {fpst}",
                        //        fpst = sym FPST
                        //    )
                        //}
                        //
                        //for a in x.adresses.clone().to_vec().into_iter() {
                        //    //if ISDEBUG { info!("trying to restore {}", a.pos) };
                        //    a.restore();
                        //    //if ISDEBUG { info!("success") };
                        //}

                        *cur_speed_iter = 1;
                        *cur_speed = 1 + diff + 3;
                        //                        let diff = 1;

                        if diff <= 0 && false {
                            pause(battle_state);
                            *cur_speed_iter = *cur_speed;
                            return;
                        }

                        break;
                    } else {
                        last = Some(x);
                        continue;
                    }
                } else {
                    //nothing can be done ?
                    if let Some(last) = last {
                        for a in last.adresses.to_vec().into_iter() {
                            a.restore();
                        }
                    }
                    pause(battle_state);
                    *cur_speed_iter = *cur_speed;

                    if ISDEBUG {
                        info!("missing frame")
                    };
                    return;
                }
            }

            if ISDEBUG {
                info!(" restore complete success")
            };
        }
    }

    let fc2 = *SOKU_FRAMECOUNT;

    let islastin = FRAMES
        .lock()
        .unwrap()
        .last()
        .map(|x| x.number == fc2)
        .unwrap_or(false);

    if islastin {
        if ISDEBUG {
            info!("lastisin")
        };
        return;
        panic!("");
    }

    if fc2 % 16 == 1 || GOOF.load(Relaxed) == 1 {
        let start = Instant::now();

        if ISDEBUG {
            info!("framecount: {}", fc2)
        };

        let frame = dump_frame();

        let mut mutex = FRAMES.lock().unwrap();

        mutex.push(frame);

        //if ISDEBUG { info!("frame size: {}", frame.size_data()) };
        //if ISDEBUG { info!("frame size: {}", frame.redundency_data()) };

        let duration = start.elapsed();

        if ISDEBUG {
            info!("time elapsed on saving: {}", duration.as_nanos())
        };
        if ISDEBUG {
            info!("frame successfull")
        };
    }

    if fc2 % 100 == 0 {
        if ISDEBUG {
            info!(
                "a: {}, b: {}, c: {}",
                A_COUNT.load(std::sync::atomic::Ordering::Relaxed),
                B_COUNT.load(std::sync::atomic::Ordering::Relaxed),
                C_COUNT.load(std::sync::atomic::Ordering::Relaxed)
            );
        }

        A_COUNT.store(0, Relaxed);
        B_COUNT.store(0, Relaxed);
        C_COUNT.store(0, Relaxed);
    }
}

#[derive(Debug, Clone, Copy, Default)]
struct Input {
    binary: [bool; 10],
    charge: [i32; 6],
}

impl Input {
    const fn zeroed() -> Self {
        Input {
            binary: [false; 10],
            charge: [0; 6],
        }
    }
}

//static RAW_SELF: Mutex<Vec<[bool; 10]>> = Mutex::new(Vec::new());
//static RAW_OTHER: Mutex<Vec<Option<[bool; 10]>>> = Mutex::new(Vec::new());

//static LATEST_1: Mutex<([bool; 10], Option<[i32; 6]>)> = Mutex::new(([false; 10], None));
//static LATEST_2: Mutex<([bool; 10], Option<[i32; 6]>)> = Mutex::new(([false; 10], None));

//static PREVIOUS_1: Mutex<Option<[i32; 6]>> = Mutex::new(None);
//static PREVIOUS_2: Mutex<Option<[i32; 6]>> = Mutex::new(None);

//static OP_INPUTS: Mutex<Vec<Input>> = Mutex::new(Vec::new());
//static OP_UPDATE: AtomicI32 = AtomicI32::new(0);

//static SELF_INPUTS: Mutex<Vec<Input>> = Mutex::new(Vec::new());

static mut SELF_INPUTS: Vec<u16> = Vec::new();

//static ROLLBACK_TARGETS: Mutex<BTreeMap<usize, GameState>> = Mutex::new(BTreeMap::new());

//purely to reduce spaghetti
#[derive(Clone, Debug)]
struct GameState {
    index: usize,
    frame: Frame, //inputs here contain the previous charge buffers
    selfinput: Input,
    otherinput: Input,
}

impl GameState {}

unsafe fn read_current_input() -> ([bool; 10], u16) {
    //return ([false; 10], 0);
    let local_input_manager = 9013560;
    let raw_input_buffer = 0x8a01b8;
    let mut input = [false; 10];
    let mut inputaccum = 0u16;

    for a in 0..10 {
        let key = (local_input_manager + 0x8 + a * 0x4) as *const u8;
        //info!("here {}", key as usize);
        let key = *key as u32;
        //info!("here");
        let key = *((raw_input_buffer + key) as *const u8) != 0;
        input[a] = key;
        if key {
            inputaccum += 0x1 << a;
        }
        //info!("{a}: {}", key)
    }

    (input, inputaccum)
}
unsafe fn send_frame_timing(frame: usize) {
    //info!("missing frame");

    let mut buf = [0u8; 400];
    buf[0] = 0x6a;
    buf[2..6].copy_from_slice(&frame.to_le_bytes());

    let w = FTIME.as_ref().unwrap();
    let m: Box<[u8]> = {
        (frame - 10..frame)
            .map(|x| {
                w.get(&x)
                    .map(|x| *x)
                    .unwrap_or(32_000 /* big value to signify you fucked up */)
                    .to_le_bytes()
            })
            .flatten()
            .collect::<Vec<_>>()
    }
    .into_boxed_slice();

    buf[6..46].copy_from_slice(&m);

    let netmanager = *(0x8986a0 as *const usize);

    let socket = netmanager + 0x3e4;

    //info!("nm {}", *(netmanager as *const usize));

    let to;
    if *(netmanager as *const usize) == 0x858cac {
        let it = (netmanager + 0x4c8) as *const usize;
        buf[1] = 1;

        if *it == 0 {
            info!("panichere");
            panic!();
        }
        to = *(it as *const *const SOCKADDR);
    } else {
        buf[1] = 2;

        if *(netmanager as *const usize) != 0x858d14 {
            info!("panichere2");
            panic!();
        }
        to = (netmanager + 0x47c) as *const SOCKADDR
    }

    //info!("about to send");
    let rse = sendto(*(socket as *const SOCKET), &buf, 0, to, 400);
    //info!("sent");
    if rse == -1 {
        info!("socket err: {:?}", WSAGetLastError());
    }
}

unsafe fn commit_input_custom(packet: NetworkPacket) {
    let mut res = packet.encode();

    res[0] = 0x69;
    //buf[6..8].copy_from_slice(&input.to_le_bytes());

    let netmanager = *(0x8986a0 as *const usize);

    let socket = netmanager + 0x3e4;

    //info!("nm {}", *(netmanager as *const usize));

    let to;
    if *(netmanager as *const usize) == 0x858cac {
        let it = (netmanager + 0x4c8) as *const usize;
        res[1] = 1;
        //std::thread::sleep(Duration::from_millis(5));
        if *it == 0 {
            info!("panichere");
            panic!();
        }
        to = *(it as *const *const SOCKADDR);
    } else {
        res[1] = 2;

        if *(netmanager as *const usize) != 0x858d14 {
            info!("panichere2");
            panic!();
        }
        to = (netmanager + 0x47c) as *const SOCKADDR
    }
    //buf[8..12].copy_from_slice(&last_rollback.to_le_bytes());

    //info!("about to send");
    let rse = sendto(*(socket as *const SOCKET), &res, 0, to, res.len() as i32);
    //info!("sent");
    if rse == -1 {
        info!("socket err: {:?}", WSAGetLastError());
    }
}
/*
unsafe fn commit_input_source(start: usize, frame: usize, source: &Vec<u16>) {
    let mut input_buffer = vec![];

    {
        let m = source;
        let w = match m.get(start..=frame) {
            Some(x) => x,
            None => {
                info!("wrong index sent: {} {}", frame, m.len());
                m.get(start..frame - 1).unwrap()
            }
        };

        for a in w.iter() {
            input_buffer.push(*a);
        }
        input_buffer.reverse();
    }

    commit_input_custom(frame, input_buffer);
}

unsafe fn commit_input(start: usize, frame: usize) {
    commit_input_source(start, frame, &SELF_INPUTS);
}
 */

static mut NTC: Option<Rollbacker> = None;

static mut DATA_SENDER: Option<std::sync::mpsc::Sender<(usize, [bool; 10])>> = None;
static mut DATA_RECEIVER: Option<std::sync::mpsc::Receiver<(usize, [bool; 10])>> = None;

static mut FRAME_TIMES: Option<DashMap<usize, SystemTime>> = None;

static DELAY: AtomicU32 = AtomicU32::new(4);
static MAX_ROLLBACK: AtomicU32 = AtomicU32::new(6);

unsafe fn make_packet() -> NetworkPacket {
    //only called on real frames

    NetworkPacket {
        id: *SOKU_FRAMECOUNT,
        desyncdetect: 0,
        delay: a,
        max_rollback: max_rollback,
        inputs: vec![],
        confirms: vec![false],
        sync: None,
    }
}

unsafe fn handle_online(
    fc2: usize,
    battle_state: &mut u32,
    cur_speed: &mut u32,
    cur_speed_iter: &mut u32,
) {
    let max_rollback: usize = 8;
    let delay = 4;
    if fc2 == 0 {
        if let Some(x) = FRAME_TIMES.as_ref().unwrap().insert(0, SystemTime::now()) {
            //panic!("frametimes not cleaned up"); got remote fc before local
            if let Some(x) = FTIME
                .as_ref()
                .unwrap()
                .insert(0, x.elapsed().unwrap().as_micros() as i32)
            {
                if x != 0 {
                    panic!("should be unreachable");
                }
                //todo: FIX
            }
        }

        let m = DATA_RECEIVER.take().unwrap();
        NTC = Some(ntc);

        let mut ntc = Rollbacker::new(m);

        commit_input(ntc, false[10]); // should consider the delay, rollback, and such, the write it to a buffer from whwich it can be send
        commit_frame(0);

        return;
    }

    let ntc = NTC.as_mut().unwrap();

    resume(battle_state);

    if *cur_speed_iter == 0 {
        let lconf = LEASTCONFIRM.load(Relaxed) as usize;
        *cur_speed = ntc.start() as u32;
        if *cur_speed > 6 {
            info!("bugged speed {}, attempting recovery", cur_speed);

            commit_input(lconf - 1, (fc2 + delay) - 1);
            pause(battle_state);
            *cur_speed = 0;
            return;
        }

        {
            //info!("confirmation: {lconf}, {fc2}");
            let tru_confirm = lconf + max_rollback - 1;
            if tru_confirm < fc2 {
                //send_missing_inputs();
                info!("missing confirm! {}", lconf);
                commit_input(lconf - 1, (fc2 + delay) - 1);
                pause(battle_state);
                *cur_speed = 0;
                return;
            }

            /*
            let framevec = &mut *ROLLBACK_TARGETS.lock().unwrap();

            if fc2 > 16 {
                if let Some(x) = framevec.remove(&(fc2 - 15)) {
                    x.frame.did_happen();
                } else {
                    //ask_for_frame(fc2 - 15);
                    info!("frame: {} was missing", fc2 - 15);
                }
            };
             */
            {
                let ft = FRAME_TIMES.as_ref().unwrap();
                let ftime = FTIME.as_ref().unwrap();

                if let Some(x) = ft.get(&fc2) {
                    // we are after the corresponding packet
                    if let Some(x) = ftime.insert(fc2, -(x.elapsed().unwrap().as_micros() as i32)) {
                        //info!("x: {x}");
                        if x != 0 {
                            panic!("x was not 0 {x}");
                        }
                        //todo!();
                    }
                } else {
                    // we are before the corresponding packet
                    if let Some(_) = ft.insert(fc2, SystemTime::now()) {
                        ftime.insert(fc2, 0);
                        //todo!();
                    }
                }
            }
            if fc2 % 10 == 0 && fc2 > 10 {
                send_frame_timing(fc2 - 10);
            }
        }

        let (input, inputaccum) = read_current_input();
        ntc.write_self(input);
        let se = &mut SELF_INPUTS;

        let target_with_delay = fc2 + delay;

        while se.len() < target_with_delay {
            se.push(inputaccum);
        }
        if se.len() > target_with_delay {
            se[target_with_delay] = inputaccum
        } else {
            se.push(inputaccum);
        }
        commit_input_source(lconf, fc2 + delay, &*se);

        //send_missing_inputs();
        //info!("speed {}", *cur_speed);
    }

    //info!("{}", *cur_speed_iter as usize);

    if let None = ntc.step(*cur_speed_iter as usize) {
        pause(battle_state);
    }

    //046c8e0 real input buffer set!!!!

    // solution to problem in my head, have a global "last frame was *true*" bool, if it's true then we dump the frame and change that global back to false
    //let input = 0x898970; //0x89a248;
    //             (*(0x8986a0 as *const usize)) + 0xf8 + 0x38;
    //let input2 = (*(0x8986a0 as *const usize)) + 0x174 + 0x38; /*0x1AC*/

    //true, actual? input buffer

    //input buffer overrider first: 40a1a0, second 40A3AB

    //th123.exe+2833A
}

unsafe extern "cdecl" fn goodhook(a: *mut ilhook::x86::Registers, _b: usize) {
    //std::thread::sleep(Duration::from_millis(5));
    //info!("esi: {}", *(((*a).esi + 4) as *const u32));

    std::panic::set_hook(Box::new(|x| info!("panic! {:?}", x)));

    //DISABLE_INPUT.store(1, Relaxed);
    let fc2 = *SOKU_FRAMECOUNT;
    //info!("goodhook: {fc2}");

    let battle_state: &mut u32;
    let cur_speed: &mut u32;
    let cur_speed_iter: &mut u32;
    {
        let w = (*a).esi;
        cur_speed = &mut (*a).ebx;
        cur_speed_iter = &mut (*a).edi;

        let m = (w + 4 * 0x22) as *mut u32; //battle phase
                                            //mystcountpos = (w + 4 * 1) as u32; //battle phase

        battle_state = &mut *m;
    }
    //898680 potential manager one
    //498718 potential manager two
    //let true_input_buffer = *(0x898680 as *const usize);
    //let ibl = (true_input_buffer + 0x38) as *mut usize;
    //*ibl = 5;

    //043e610 !!!!!!!!!!

    //info!("gametype {}", *(0x898688 as *const usize));

    match *(0x898688 as *const usize) {
        2 => handle_replay(fc2, battle_state, cur_speed, cur_speed_iter), //2 is replay
        1 /*?*/ => handle_online(fc2, battle_state, cur_speed, cur_speed_iter),
        _ => ()
    }

    // a packet should have the following information: number; last round trip, if applicable; input for that frame
    // when a packet is skipped or not received in time we try again with a different field

    //8a01b8 true input

    //00898938 + 62
    //40A467 -> writes to the input buffer

    //00899d4c other buffer?

    //008986a0 other input buffer. ((*008986a0) + 0x1AC)
    //true input buffer: 0x898970

    //info!("{:?}", read_addr(input2, 0x68).usize_align());
    //*(input as *mut usize) = 4;

    //info!(", {:?}", read_addr(input, 0x40).usize_align());

    /*

    const NPO: *mut usize = 0x8986a0 as *mut usize;
    if NPO as usize != 0 {
        let rel = (*NPO) +  0x160;

        let buf = read_addr(rel, 20).usize_align();
        let b: Result<[usize; 5], _> = (*buf).try_into();
        let [junk, ptr, size, c, underlying] = b.unwrap();

        //info!("relz: {:#x}", (ptr));
    }
    */

    //unsafe {
    //    if ISDEBUG {
    //        info!("moutain_vapor: {}", *(0x8971C0 as *const usize))
    //    }
    //}; 65793

    //replay detect

    //framecount 2 008985d8
}
